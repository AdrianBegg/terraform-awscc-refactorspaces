# Example : Deploying and configuring AWS Refactor Spaces in a single account

The following example deploys AWS Refactor Spaces components within a single AWS Account including the environment, application and all service routes. This is recommended only for proof-of-concept or testing purposes; in Production it is recommended that micro-services are deployed in separate AWS accounts in order to simplify implementation of least-privilege access models for a single application scope, simplify internal resource tracking and charge-back and service limits and quotas.

<p align="center">
  <img src="https://raw.githubusercontent.com/aws-ia/terraform-aws-refactorspaces/main/images/aws_migration_hub_refactor_spaces_basic.png" alt="Simple" width="75%">
</p>

Figure 1. Example configuration of AWS Migration Hub Refactor Spaces with a monolithic application 'Unishop' with the AddToCart strangled as a Lambda microservice.

This example would deploy the following:

* An Amazon VPC "vpc-application-example-proxy" with IPv4 CIDR 192.168.10.0/24 and two 27-bit private subnets
* A AWS Migration Hub Refactor Spaces environment named "unicorn-dev"
* A AWS Migration Hub Refactor Spaces application named "Unistore"
* A AWS Migration Hub Refactor Spaces service "Unistore-legacy" pointing to a monolithic application deployed on Amazon EC2/ECS/EKS or similar services running in a VPC with a DNS name `http://legacy-unicorns.example.com/` acting as the default route
* A AWS Migration Hub Refactor Spaces service "Unistore-AddToCartService" pointing at a microservice deployed as AWS Lambda Function with the ARN `arn:aws:lambda:us-east-1:999999999999:function:AddToCart`. 
* A route that sends `POST` and `GET` requests to `/unicorns/basket` to the AWS Lambda function