# Example: Deploying and configuring AWS Refactor Spaces in a single account

The following example deploys AWS Refactor Spaces components within a single AWS account including the environment, application, and all service routes. We recommend only using this for proof-of-concept or testing purposes. In production, deploy microservices in separate AWS accounts to simplify implementation of least privilege access models for a single application scope, simplify internal resource tracking and chargeback, and service limits and quotas.

<p align="center">
  <img src="https://raw.githubusercontent.com/aws-ia/terraform-awscc-refactorspaces/main/images/aws_migration_hub_refactor_spaces_basic.png" alt="Simple" width="75%">
</p>

Figure 1. Example configuration of AWS Migration Hub Refactor Spaces with a monolithic application _Unishop_ with the AddToCart strangled as an AWS Lambda microservice.

As shown in the diagram, this example sets up the following:

* An Amazon VPC "vpc-application-example-proxy" with IPv4 CIDR 192.168.10.0/24 and two 27-bit private subnets.
* An AWS Migration Hub Refactor Spaces environment named _unicorn-dev_.
* An AWS Migration Hub Refactor Spaces application named _Unistore_.
* The following AWS Migration Hub Refactor Spaces services:
** _Unistore-legacy_ pointing to a monolithic application deployed on Amazon Elastic Compute Cloud (Amazon EC2), Amazon Elastic Container Service (Amazon ECS), Amazon Elastic Kubernetes Service (Amazon EKS), or similar services. This service is running in a VPC with a DNS name _http://legacy-unicorns.example.com/_, acting as the default route.
** _Unistore-AddToCartService_ pointing at a microservice deployed as a Lambda Function with the Amazon Resource Name (ARN) `arn:aws:lambda:us-east-1:999999999999:function:AddToCart`.
* A route that sends `POST` and `GET` requests to `/unicorns/basket` to the Lambda function.
